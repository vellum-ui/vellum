use super::color::ColorValue;
use serde::{Deserialize, Serialize};
use std::fmt;

/// Commands generated by the runtime and sent to the UI thread
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ClientCommand {
    /// Set the window title
    SetTitle(String),

    /// Create a new widget with optional styling and widget-specific data
    CreateWidget {
        id: String,
        kind: WidgetKind,
        parent_id: Option<String>,
        text: Option<String>,
        style: Option<BoxStyle>,
        data: Option<WidgetData>,
    },

    /// Remove a widget
    RemoveWidget { id: String },

    /// Set widget text content
    SetWidgetText { id: String, text: String },

    /// Set widget visibility
    SetWidgetVisible { id: String, visible: bool },

    /// Apply style to an existing widget
    SetWidgetStyle { id: String, style: BoxStyle },

    /// Set a single style property on a widget
    SetStyleProperty {
        id: String,
        property: String,
        value: String,
    },

    /// Set progress on a ProgressBar (0.0 to 1.0)
    SetWidgetValue { id: String, value: f64 },

    /// Set image data on an Image widget (raw file bytes)
    SetImageData { id: String, data: Vec<u8> },

    /// Set whether a checkbox is checked
    SetWidgetChecked { id: String, checked: bool },

    /// Request window resize
    ResizeWindow { width: u32, height: u32 },

    /// Request window close
    CloseWindow,

    /// Request to exit the application
    ExitApp,
}

/// Widget types that can be created
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum WidgetKind {
    Label,
    Button,
    Svg,
    Image,
    TextInput,
    TextArea,
    Checkbox,
    Flex,
    Container,
    SizedBox,
    ProgressBar,
    Spinner,
    Slider,
    Prose,
    Grid,
    ZStack,
    Portal,
    Hoverable,
    Custom(String),
}

/// Widget-specific initialization data.
/// Each variant carries only the data relevant to that widget kind,
/// ensuring type safety and preventing nonsensical combinations.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum WidgetData {
    /// Label — no extra data (text comes from the `text` field)
    Label,

    /// Button — optional SVG icon data
    Button { svg_data: Option<String> },

    /// SVG widget
    Svg { svg_data: Option<String> },

    /// Image widget — raw image bytes + display mode
    Image {
        data: Vec<u8>,
        object_fit: Option<String>,
    },

    /// Flex / Container layout (all layout fields come from BoxStyle)
    Flex,

    /// SizedBox — uses width/height from BoxStyle
    SizedBox,

    /// Checkbox initial state
    Checkbox { checked: bool },

    /// TextInput with placeholder
    TextInput { placeholder: Option<String> },

    /// TextArea — no extra data (text comes from the `text` field)
    TextArea,

    /// Prose — no extra data (text comes from the `text` field)
    Prose,

    /// ProgressBar initial value
    ProgressBar { progress: Option<f64> },

    /// Spinner — no extra data
    Spinner,

    /// Slider range and initial value
    Slider {
        min: f64,
        max: f64,
        value: f64,
        step: Option<f64>,
    },

    /// ZStack — no extra data
    ZStack,

    /// Portal (scroll container) — no extra data
    Portal,

    /// Grid — no extra data (fallback to Flex)
    Grid,

    /// Hoverable — container that tracks hover state
    Hoverable,

    /// Custom widget
    Custom(String),
}

/// Shared box-model + text styling applied to any widget.
/// Contains only layout and visual properties common to all widget types.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct BoxStyle {
    // -- Text styles --
    pub font_size: Option<f32>,
    pub font_weight: Option<f32>,
    pub font_style: Option<FontStyleValue>,
    pub font_family: Option<String>,
    pub color: Option<ColorValue>,
    pub letter_spacing: Option<f32>,
    pub line_height: Option<f32>,
    pub word_spacing: Option<f32>,
    pub underline: Option<bool>,
    pub strikethrough: Option<bool>,
    pub text_align: Option<TextAlignValue>,

    // -- Box / layout styles --
    pub background: Option<ColorValue>,
    pub border_color: Option<ColorValue>,
    pub hover_border_color: Option<ColorValue>,
    pub border_width: Option<f64>,
    pub corner_radius: Option<f64>,
    pub padding: Option<PaddingValue>,
    pub width: Option<f64>,
    pub height: Option<f64>,

    // -- Flex-child property (how this widget behaves inside a Flex parent) --
    pub flex: Option<f64>,

    // -- Flex container styles (for Flex/Container/Button inner layout) --
    pub direction: Option<FlexDirection>,
    pub cross_axis_alignment: Option<CrossAlign>,
    pub main_axis_alignment: Option<MainAlign>,
    pub gap: Option<f64>,
    pub must_fill_main_axis: Option<bool>,
}

/// Font style (normal vs italic)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum FontStyleValue {
    Normal,
    Italic,
}

/// Text alignment
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum TextAlignValue {
    Start,
    Center,
    End,
    Justify,
}

/// Flex direction
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum FlexDirection {
    Row,
    Column,
}

/// Cross axis alignment for Flex
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum CrossAlign {
    Start,
    Center,
    End,
    Fill,
    Baseline,
}

/// Main axis alignment for Flex
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum MainAlign {
    Start,
    Center,
    End,
    SpaceBetween,
    SpaceAround,
    SpaceEvenly,
}

/// Padding (uniform or per-side)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PaddingValue {
    Uniform(f64),
    Sides {
        top: f64,
        right: f64,
        bottom: f64,
        left: f64,
    },
}

/// Wrapper around ClientCommand that can be sent as an ErasedAction through the EventLoopProxy.
/// ErasedAction = Box<dyn AnyDebug + Send>, where AnyDebug is auto-implemented for Any + Debug.
/// So this type just needs Debug + Send + 'static (ClientCommand is Clone+Debug, all String fields).
pub struct ClientCommandAction(pub ClientCommand);

impl fmt::Debug for ClientCommandAction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "ClientCommandAction({:?})", self.0)
    }
}

// ── Helpers for parsing style from JSON-like data ──

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_client_command_serialization() {
        let cmd = ClientCommand::SetTitle("Hello AppJS".to_string());

        let serialized = serde_json::to_string(&cmd).unwrap();
        assert!(serialized.contains("SetTitle"));
        assert!(serialized.contains("Hello AppJS"));

        let deserialized: ClientCommand = serde_json::from_str(&serialized).unwrap();
        match deserialized {
            ClientCommand::SetTitle(title) => assert_eq!(title, "Hello AppJS"),
            _ => panic!("Deserialized to wrong variant"),
        }
    }

    #[test]
    fn test_create_widget_serialization() {
        let cmd = ClientCommand::CreateWidget {
            id: "btn_1".to_string(),
            kind: WidgetKind::Button,
            parent_id: Some("__root__".to_string()),
            text: Some("Click Me".to_string()),
            style: Some(BoxStyle {
                width: Some(100.0),
                height: Some(40.0),
                ..Default::default()
            }),
            data: Some(WidgetData::Button { svg_data: None }),
        };

        let serialized = serde_json::to_string(&cmd).unwrap();
        assert!(serialized.contains("CreateWidget"));
        assert!(serialized.contains("Button"));
        assert!(serialized.contains("btn_1"));

        let deserialized: ClientCommand = serde_json::from_str(&serialized).unwrap();
        if let ClientCommand::CreateWidget { id, kind, .. } = deserialized {
            assert_eq!(id, "btn_1");
            assert!(matches!(kind, WidgetKind::Button));
        } else {
            panic!("Deserialized to wrong variant");
        }
    }

    #[test]
    fn test_client_command_action_debug() {
        let cmd = ClientCommand::ExitApp;
        let action = ClientCommandAction(cmd);
        let debug_str = format!("{:?}", action);
        assert!(debug_str.contains("ClientCommandAction"));
        assert!(debug_str.contains("ExitApp"));
    }
}
