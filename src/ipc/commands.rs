use super::color::ColorValue;
use serde::{Deserialize, Serialize};
use std::fmt;

/// Commands generated by the JS runtime and sent to the UI thread
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum JsCommand {
    /// Set the window title
    SetTitle(String),

    /// Create a new widget with optional styling
    CreateWidget {
        id: String,
        kind: WidgetKind,
        parent_id: Option<String>,
        text: Option<String>,
        style: Option<WidgetStyle>,
    },

    /// Remove a widget
    RemoveWidget { id: String },

    /// Set widget text content
    SetWidgetText { id: String, text: String },

    /// Set widget visibility
    SetWidgetVisible { id: String, visible: bool },

    /// Apply style to an existing widget
    SetWidgetStyle { id: String, style: WidgetStyle },

    /// Set a single style property on a widget
    SetStyleProperty {
        id: String,
        property: String,
        value: String,
    },

    /// Set progress on a ProgressBar (0.0 to 1.0)
    SetWidgetValue { id: String, value: f64 },

    /// Set whether a checkbox is checked
    SetWidgetChecked { id: String, checked: bool },

    /// Request window resize
    ResizeWindow { width: u32, height: u32 },

    /// Request window close
    CloseWindow,

    /// Log a message (for debugging)
    Log { level: LogLevel, message: String },

    /// Request to exit the application
    ExitApp,
}

/// Widget types that can be created
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum WidgetKind {
    Label,
    Button,
    IconButton,
    Svg,
    TextInput,
    TextArea,
    Checkbox,
    Flex,
    Container,
    SizedBox,
    ProgressBar,
    Spinner,
    Slider,
    Prose,
    Grid,
    ZStack,
    Portal,
    Custom(String),
}

/// Comprehensive styling that can be applied to widgets
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct WidgetStyle {
    // -- Text styles --
    pub font_size: Option<f32>,
    pub font_weight: Option<f32>,
    pub font_style: Option<FontStyleValue>,
    pub font_family: Option<String>,
    pub color: Option<ColorValue>,
    pub letter_spacing: Option<f32>,
    pub line_height: Option<f32>,
    pub word_spacing: Option<f32>,
    pub underline: Option<bool>,
    pub strikethrough: Option<bool>,
    pub text_align: Option<TextAlignValue>,

    // -- Box / layout styles --
    pub background: Option<ColorValue>,
    pub border_color: Option<ColorValue>,
    pub border_width: Option<f64>,
    pub corner_radius: Option<f64>,
    pub padding: Option<PaddingValue>,
    pub width: Option<f64>,
    pub height: Option<f64>,

    // -- Flex-specific styles --
    pub direction: Option<FlexDirection>,
    pub cross_axis_alignment: Option<CrossAlign>,
    pub main_axis_alignment: Option<MainAlign>,
    pub gap: Option<f64>,
    pub flex: Option<f64>,
    pub must_fill_main_axis: Option<bool>,

    // -- Slider-specific --
    pub min_value: Option<f64>,
    pub max_value: Option<f64>,
    pub step: Option<f64>,

    // -- Checkbox --
    pub checked: Option<bool>,

    // -- ProgressBar --
    pub progress: Option<f64>,

    // -- TextInput --
    pub placeholder: Option<String>,

    // -- SVG/Image --
    pub svg_data: Option<String>,
    pub icon_size: Option<f64>,
}

/// Font style (normal vs italic)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FontStyleValue {
    Normal,
    Italic,
}

/// Text alignment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TextAlignValue {
    Start,
    Center,
    End,
    Justify,
}

/// Flex direction
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FlexDirection {
    Row,
    Column,
}

/// Cross axis alignment for Flex
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CrossAlign {
    Start,
    Center,
    End,
    Fill,
    Baseline,
}

/// Main axis alignment for Flex
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MainAlign {
    Start,
    Center,
    End,
    SpaceBetween,
    SpaceAround,
    SpaceEvenly,
}

/// Padding (uniform or per-side)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PaddingValue {
    Uniform(f64),
    Sides {
        top: f64,
        right: f64,
        bottom: f64,
        left: f64,
    },
}

/// Log levels for debugging
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LogLevel {
    Debug,
    Info,
    Warn,
    Error,
}

/// Wrapper around JsCommand that can be sent as an ErasedAction through the EventLoopProxy.
/// ErasedAction = Box<dyn AnyDebug + Send>, where AnyDebug is auto-implemented for Any + Debug.
/// So this type just needs Debug + Send + 'static (JsCommand is Clone+Debug, all String fields).
pub struct JsCommandAction(pub JsCommand);

impl fmt::Debug for JsCommandAction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "JsCommandAction({:?})", self.0)
    }
}

// ── Helpers for parsing style from JSON-like data ──
